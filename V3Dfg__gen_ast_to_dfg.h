// Generated by astgen // -*- mode: C++; c-file-style: "cc-mode" -*-
void visit(AstAdd* nodep) override {
    UASSERT_OBJ(m_converting, nodep, "AstToDfg visit called without m_converting");
    UASSERT_OBJ(!nodep->user2p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    const DfgDataType* const dtypep = DfgDataType::fromAst(nodep->dtypep());
    if (!dtypep) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepDType;
        return;
    }

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user2p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user2p(), nodep, "Child 2 missing Dfg vertex");

    DfgAdd* const vtxp = makeVertex<DfgAdd>(nodep, m_dfg, *dtypep);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepNode;
        return;
    }
    m_logicp->synth().emplace_back(vtxp);

    vtxp->inputp(0, nodep->op1p()->user2u().to<DfgVertex*>());
    vtxp->inputp(1, nodep->op2p()->user2u().to<DfgVertex*>());

    nodep->user2p(vtxp);
}
void visit(AstAnd* nodep) override {
    UASSERT_OBJ(m_converting, nodep, "AstToDfg visit called without m_converting");
    UASSERT_OBJ(!nodep->user2p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    const DfgDataType* const dtypep = DfgDataType::fromAst(nodep->dtypep());
    if (!dtypep) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepDType;
        return;
    }

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user2p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user2p(), nodep, "Child 2 missing Dfg vertex");

    DfgAnd* const vtxp = makeVertex<DfgAnd>(nodep, m_dfg, *dtypep);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepNode;
        return;
    }
    m_logicp->synth().emplace_back(vtxp);

    vtxp->inputp(0, nodep->op1p()->user2u().to<DfgVertex*>());
    vtxp->inputp(1, nodep->op2p()->user2u().to<DfgVertex*>());

    nodep->user2p(vtxp);
}
void visit(AstArraySel* nodep) override {
    UASSERT_OBJ(m_converting, nodep, "AstToDfg visit called without m_converting");
    UASSERT_OBJ(!nodep->user2p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    const DfgDataType* const dtypep = DfgDataType::fromAst(nodep->dtypep());
    if (!dtypep) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepDType;
        return;
    }

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user2p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user2p(), nodep, "Child 2 missing Dfg vertex");

    DfgArraySel* const vtxp = makeVertex<DfgArraySel>(nodep, m_dfg, *dtypep);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepNode;
        return;
    }
    m_logicp->synth().emplace_back(vtxp);

    vtxp->inputp(0, nodep->op1p()->user2u().to<DfgVertex*>());
    vtxp->inputp(1, nodep->op2p()->user2u().to<DfgVertex*>());

    nodep->user2p(vtxp);
}
void visit(AstBufIf1* nodep) override {
    UASSERT_OBJ(m_converting, nodep, "AstToDfg visit called without m_converting");
    UASSERT_OBJ(!nodep->user2p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    const DfgDataType* const dtypep = DfgDataType::fromAst(nodep->dtypep());
    if (!dtypep) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepDType;
        return;
    }

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user2p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user2p(), nodep, "Child 2 missing Dfg vertex");

    DfgBufIf1* const vtxp = makeVertex<DfgBufIf1>(nodep, m_dfg, *dtypep);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepNode;
        return;
    }
    m_logicp->synth().emplace_back(vtxp);

    vtxp->inputp(0, nodep->op1p()->user2u().to<DfgVertex*>());
    vtxp->inputp(1, nodep->op2p()->user2u().to<DfgVertex*>());

    nodep->user2p(vtxp);
}
void visit(AstConcat* nodep) override {
    UASSERT_OBJ(m_converting, nodep, "AstToDfg visit called without m_converting");
    UASSERT_OBJ(!nodep->user2p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    const DfgDataType* const dtypep = DfgDataType::fromAst(nodep->dtypep());
    if (!dtypep) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepDType;
        return;
    }

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user2p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user2p(), nodep, "Child 2 missing Dfg vertex");

    DfgConcat* const vtxp = makeVertex<DfgConcat>(nodep, m_dfg, *dtypep);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepNode;
        return;
    }
    m_logicp->synth().emplace_back(vtxp);

    vtxp->inputp(0, nodep->op1p()->user2u().to<DfgVertex*>());
    vtxp->inputp(1, nodep->op2p()->user2u().to<DfgVertex*>());

    nodep->user2p(vtxp);
}
void visit(AstCond* nodep) override {
    UASSERT_OBJ(m_converting, nodep, "AstToDfg visit called without m_converting");
    UASSERT_OBJ(!nodep->user2p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    const DfgDataType* const dtypep = DfgDataType::fromAst(nodep->dtypep());
    if (!dtypep) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepDType;
        return;
    }

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user2p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user2p(), nodep, "Child 2 missing Dfg vertex");
    iterate(nodep->op3p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op3p()->user2p(), nodep, "Child 3 missing Dfg vertex");

    DfgCond* const vtxp = makeVertex<DfgCond>(nodep, m_dfg, *dtypep);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepNode;
        return;
    }
    m_logicp->synth().emplace_back(vtxp);

    vtxp->inputp(0, nodep->op1p()->user2u().to<DfgVertex*>());
    vtxp->inputp(1, nodep->op2p()->user2u().to<DfgVertex*>());
    vtxp->inputp(2, nodep->op3p()->user2u().to<DfgVertex*>());

    nodep->user2p(vtxp);
}
void visit(AstDiv* nodep) override {
    UASSERT_OBJ(m_converting, nodep, "AstToDfg visit called without m_converting");
    UASSERT_OBJ(!nodep->user2p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    const DfgDataType* const dtypep = DfgDataType::fromAst(nodep->dtypep());
    if (!dtypep) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepDType;
        return;
    }

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user2p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user2p(), nodep, "Child 2 missing Dfg vertex");

    DfgDiv* const vtxp = makeVertex<DfgDiv>(nodep, m_dfg, *dtypep);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepNode;
        return;
    }
    m_logicp->synth().emplace_back(vtxp);

    vtxp->inputp(0, nodep->op1p()->user2u().to<DfgVertex*>());
    vtxp->inputp(1, nodep->op2p()->user2u().to<DfgVertex*>());

    nodep->user2p(vtxp);
}
void visit(AstDivS* nodep) override {
    UASSERT_OBJ(m_converting, nodep, "AstToDfg visit called without m_converting");
    UASSERT_OBJ(!nodep->user2p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    const DfgDataType* const dtypep = DfgDataType::fromAst(nodep->dtypep());
    if (!dtypep) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepDType;
        return;
    }

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user2p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user2p(), nodep, "Child 2 missing Dfg vertex");

    DfgDivS* const vtxp = makeVertex<DfgDivS>(nodep, m_dfg, *dtypep);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepNode;
        return;
    }
    m_logicp->synth().emplace_back(vtxp);

    vtxp->inputp(0, nodep->op1p()->user2u().to<DfgVertex*>());
    vtxp->inputp(1, nodep->op2p()->user2u().to<DfgVertex*>());

    nodep->user2p(vtxp);
}
void visit(AstEq* nodep) override {
    UASSERT_OBJ(m_converting, nodep, "AstToDfg visit called without m_converting");
    UASSERT_OBJ(!nodep->user2p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    const DfgDataType* const dtypep = DfgDataType::fromAst(nodep->dtypep());
    if (!dtypep) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepDType;
        return;
    }

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user2p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user2p(), nodep, "Child 2 missing Dfg vertex");

    DfgEq* const vtxp = makeVertex<DfgEq>(nodep, m_dfg, *dtypep);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepNode;
        return;
    }
    m_logicp->synth().emplace_back(vtxp);

    vtxp->inputp(0, nodep->op1p()->user2u().to<DfgVertex*>());
    vtxp->inputp(1, nodep->op2p()->user2u().to<DfgVertex*>());

    nodep->user2p(vtxp);
}
void visit(AstEqCase* nodep) override {
    UASSERT_OBJ(m_converting, nodep, "AstToDfg visit called without m_converting");
    UASSERT_OBJ(!nodep->user2p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    const DfgDataType* const dtypep = DfgDataType::fromAst(nodep->dtypep());
    if (!dtypep) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepDType;
        return;
    }

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user2p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user2p(), nodep, "Child 2 missing Dfg vertex");

    DfgEqCase* const vtxp = makeVertex<DfgEqCase>(nodep, m_dfg, *dtypep);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepNode;
        return;
    }
    m_logicp->synth().emplace_back(vtxp);

    vtxp->inputp(0, nodep->op1p()->user2u().to<DfgVertex*>());
    vtxp->inputp(1, nodep->op2p()->user2u().to<DfgVertex*>());

    nodep->user2p(vtxp);
}
void visit(AstEqWild* nodep) override {
    UASSERT_OBJ(m_converting, nodep, "AstToDfg visit called without m_converting");
    UASSERT_OBJ(!nodep->user2p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    const DfgDataType* const dtypep = DfgDataType::fromAst(nodep->dtypep());
    if (!dtypep) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepDType;
        return;
    }

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user2p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user2p(), nodep, "Child 2 missing Dfg vertex");

    DfgEqWild* const vtxp = makeVertex<DfgEqWild>(nodep, m_dfg, *dtypep);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepNode;
        return;
    }
    m_logicp->synth().emplace_back(vtxp);

    vtxp->inputp(0, nodep->op1p()->user2u().to<DfgVertex*>());
    vtxp->inputp(1, nodep->op2p()->user2u().to<DfgVertex*>());

    nodep->user2p(vtxp);
}
void visit(AstExtend* nodep) override {
    UASSERT_OBJ(m_converting, nodep, "AstToDfg visit called without m_converting");
    UASSERT_OBJ(!nodep->user2p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    const DfgDataType* const dtypep = DfgDataType::fromAst(nodep->dtypep());
    if (!dtypep) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepDType;
        return;
    }

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user2p(), nodep, "Child 1 missing Dfg vertex");

    DfgExtend* const vtxp = makeVertex<DfgExtend>(nodep, m_dfg, *dtypep);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepNode;
        return;
    }
    m_logicp->synth().emplace_back(vtxp);

    vtxp->inputp(0, nodep->op1p()->user2u().to<DfgVertex*>());

    nodep->user2p(vtxp);
}
void visit(AstExtendS* nodep) override {
    UASSERT_OBJ(m_converting, nodep, "AstToDfg visit called without m_converting");
    UASSERT_OBJ(!nodep->user2p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    const DfgDataType* const dtypep = DfgDataType::fromAst(nodep->dtypep());
    if (!dtypep) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepDType;
        return;
    }

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user2p(), nodep, "Child 1 missing Dfg vertex");

    DfgExtendS* const vtxp = makeVertex<DfgExtendS>(nodep, m_dfg, *dtypep);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepNode;
        return;
    }
    m_logicp->synth().emplace_back(vtxp);

    vtxp->inputp(0, nodep->op1p()->user2u().to<DfgVertex*>());

    nodep->user2p(vtxp);
}
void visit(AstGt* nodep) override {
    UASSERT_OBJ(m_converting, nodep, "AstToDfg visit called without m_converting");
    UASSERT_OBJ(!nodep->user2p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    const DfgDataType* const dtypep = DfgDataType::fromAst(nodep->dtypep());
    if (!dtypep) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepDType;
        return;
    }

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user2p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user2p(), nodep, "Child 2 missing Dfg vertex");

    DfgGt* const vtxp = makeVertex<DfgGt>(nodep, m_dfg, *dtypep);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepNode;
        return;
    }
    m_logicp->synth().emplace_back(vtxp);

    vtxp->inputp(0, nodep->op1p()->user2u().to<DfgVertex*>());
    vtxp->inputp(1, nodep->op2p()->user2u().to<DfgVertex*>());

    nodep->user2p(vtxp);
}
void visit(AstGtS* nodep) override {
    UASSERT_OBJ(m_converting, nodep, "AstToDfg visit called without m_converting");
    UASSERT_OBJ(!nodep->user2p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    const DfgDataType* const dtypep = DfgDataType::fromAst(nodep->dtypep());
    if (!dtypep) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepDType;
        return;
    }

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user2p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user2p(), nodep, "Child 2 missing Dfg vertex");

    DfgGtS* const vtxp = makeVertex<DfgGtS>(nodep, m_dfg, *dtypep);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepNode;
        return;
    }
    m_logicp->synth().emplace_back(vtxp);

    vtxp->inputp(0, nodep->op1p()->user2u().to<DfgVertex*>());
    vtxp->inputp(1, nodep->op2p()->user2u().to<DfgVertex*>());

    nodep->user2p(vtxp);
}
void visit(AstGte* nodep) override {
    UASSERT_OBJ(m_converting, nodep, "AstToDfg visit called without m_converting");
    UASSERT_OBJ(!nodep->user2p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    const DfgDataType* const dtypep = DfgDataType::fromAst(nodep->dtypep());
    if (!dtypep) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepDType;
        return;
    }

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user2p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user2p(), nodep, "Child 2 missing Dfg vertex");

    DfgGte* const vtxp = makeVertex<DfgGte>(nodep, m_dfg, *dtypep);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepNode;
        return;
    }
    m_logicp->synth().emplace_back(vtxp);

    vtxp->inputp(0, nodep->op1p()->user2u().to<DfgVertex*>());
    vtxp->inputp(1, nodep->op2p()->user2u().to<DfgVertex*>());

    nodep->user2p(vtxp);
}
void visit(AstGteS* nodep) override {
    UASSERT_OBJ(m_converting, nodep, "AstToDfg visit called without m_converting");
    UASSERT_OBJ(!nodep->user2p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    const DfgDataType* const dtypep = DfgDataType::fromAst(nodep->dtypep());
    if (!dtypep) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepDType;
        return;
    }

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user2p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user2p(), nodep, "Child 2 missing Dfg vertex");

    DfgGteS* const vtxp = makeVertex<DfgGteS>(nodep, m_dfg, *dtypep);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepNode;
        return;
    }
    m_logicp->synth().emplace_back(vtxp);

    vtxp->inputp(0, nodep->op1p()->user2u().to<DfgVertex*>());
    vtxp->inputp(1, nodep->op2p()->user2u().to<DfgVertex*>());

    nodep->user2p(vtxp);
}
void visit(AstLogAnd* nodep) override {
    UASSERT_OBJ(m_converting, nodep, "AstToDfg visit called without m_converting");
    UASSERT_OBJ(!nodep->user2p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    const DfgDataType* const dtypep = DfgDataType::fromAst(nodep->dtypep());
    if (!dtypep) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepDType;
        return;
    }

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user2p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user2p(), nodep, "Child 2 missing Dfg vertex");

    DfgLogAnd* const vtxp = makeVertex<DfgLogAnd>(nodep, m_dfg, *dtypep);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepNode;
        return;
    }
    m_logicp->synth().emplace_back(vtxp);

    vtxp->inputp(0, nodep->op1p()->user2u().to<DfgVertex*>());
    vtxp->inputp(1, nodep->op2p()->user2u().to<DfgVertex*>());

    nodep->user2p(vtxp);
}
void visit(AstLogEq* nodep) override {
    UASSERT_OBJ(m_converting, nodep, "AstToDfg visit called without m_converting");
    UASSERT_OBJ(!nodep->user2p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    const DfgDataType* const dtypep = DfgDataType::fromAst(nodep->dtypep());
    if (!dtypep) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepDType;
        return;
    }

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user2p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user2p(), nodep, "Child 2 missing Dfg vertex");

    DfgLogEq* const vtxp = makeVertex<DfgLogEq>(nodep, m_dfg, *dtypep);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepNode;
        return;
    }
    m_logicp->synth().emplace_back(vtxp);

    vtxp->inputp(0, nodep->op1p()->user2u().to<DfgVertex*>());
    vtxp->inputp(1, nodep->op2p()->user2u().to<DfgVertex*>());

    nodep->user2p(vtxp);
}
void visit(AstLogIf* nodep) override {
    UASSERT_OBJ(m_converting, nodep, "AstToDfg visit called without m_converting");
    UASSERT_OBJ(!nodep->user2p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    const DfgDataType* const dtypep = DfgDataType::fromAst(nodep->dtypep());
    if (!dtypep) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepDType;
        return;
    }

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user2p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user2p(), nodep, "Child 2 missing Dfg vertex");

    DfgLogIf* const vtxp = makeVertex<DfgLogIf>(nodep, m_dfg, *dtypep);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepNode;
        return;
    }
    m_logicp->synth().emplace_back(vtxp);

    vtxp->inputp(0, nodep->op1p()->user2u().to<DfgVertex*>());
    vtxp->inputp(1, nodep->op2p()->user2u().to<DfgVertex*>());

    nodep->user2p(vtxp);
}
void visit(AstLogNot* nodep) override {
    UASSERT_OBJ(m_converting, nodep, "AstToDfg visit called without m_converting");
    UASSERT_OBJ(!nodep->user2p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    const DfgDataType* const dtypep = DfgDataType::fromAst(nodep->dtypep());
    if (!dtypep) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepDType;
        return;
    }

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user2p(), nodep, "Child 1 missing Dfg vertex");

    DfgLogNot* const vtxp = makeVertex<DfgLogNot>(nodep, m_dfg, *dtypep);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepNode;
        return;
    }
    m_logicp->synth().emplace_back(vtxp);

    vtxp->inputp(0, nodep->op1p()->user2u().to<DfgVertex*>());

    nodep->user2p(vtxp);
}
void visit(AstLogOr* nodep) override {
    UASSERT_OBJ(m_converting, nodep, "AstToDfg visit called without m_converting");
    UASSERT_OBJ(!nodep->user2p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    const DfgDataType* const dtypep = DfgDataType::fromAst(nodep->dtypep());
    if (!dtypep) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepDType;
        return;
    }

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user2p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user2p(), nodep, "Child 2 missing Dfg vertex");

    DfgLogOr* const vtxp = makeVertex<DfgLogOr>(nodep, m_dfg, *dtypep);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepNode;
        return;
    }
    m_logicp->synth().emplace_back(vtxp);

    vtxp->inputp(0, nodep->op1p()->user2u().to<DfgVertex*>());
    vtxp->inputp(1, nodep->op2p()->user2u().to<DfgVertex*>());

    nodep->user2p(vtxp);
}
void visit(AstLt* nodep) override {
    UASSERT_OBJ(m_converting, nodep, "AstToDfg visit called without m_converting");
    UASSERT_OBJ(!nodep->user2p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    const DfgDataType* const dtypep = DfgDataType::fromAst(nodep->dtypep());
    if (!dtypep) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepDType;
        return;
    }

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user2p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user2p(), nodep, "Child 2 missing Dfg vertex");

    DfgLt* const vtxp = makeVertex<DfgLt>(nodep, m_dfg, *dtypep);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepNode;
        return;
    }
    m_logicp->synth().emplace_back(vtxp);

    vtxp->inputp(0, nodep->op1p()->user2u().to<DfgVertex*>());
    vtxp->inputp(1, nodep->op2p()->user2u().to<DfgVertex*>());

    nodep->user2p(vtxp);
}
void visit(AstLtS* nodep) override {
    UASSERT_OBJ(m_converting, nodep, "AstToDfg visit called without m_converting");
    UASSERT_OBJ(!nodep->user2p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    const DfgDataType* const dtypep = DfgDataType::fromAst(nodep->dtypep());
    if (!dtypep) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepDType;
        return;
    }

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user2p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user2p(), nodep, "Child 2 missing Dfg vertex");

    DfgLtS* const vtxp = makeVertex<DfgLtS>(nodep, m_dfg, *dtypep);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepNode;
        return;
    }
    m_logicp->synth().emplace_back(vtxp);

    vtxp->inputp(0, nodep->op1p()->user2u().to<DfgVertex*>());
    vtxp->inputp(1, nodep->op2p()->user2u().to<DfgVertex*>());

    nodep->user2p(vtxp);
}
void visit(AstLte* nodep) override {
    UASSERT_OBJ(m_converting, nodep, "AstToDfg visit called without m_converting");
    UASSERT_OBJ(!nodep->user2p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    const DfgDataType* const dtypep = DfgDataType::fromAst(nodep->dtypep());
    if (!dtypep) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepDType;
        return;
    }

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user2p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user2p(), nodep, "Child 2 missing Dfg vertex");

    DfgLte* const vtxp = makeVertex<DfgLte>(nodep, m_dfg, *dtypep);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepNode;
        return;
    }
    m_logicp->synth().emplace_back(vtxp);

    vtxp->inputp(0, nodep->op1p()->user2u().to<DfgVertex*>());
    vtxp->inputp(1, nodep->op2p()->user2u().to<DfgVertex*>());

    nodep->user2p(vtxp);
}
void visit(AstLteS* nodep) override {
    UASSERT_OBJ(m_converting, nodep, "AstToDfg visit called without m_converting");
    UASSERT_OBJ(!nodep->user2p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    const DfgDataType* const dtypep = DfgDataType::fromAst(nodep->dtypep());
    if (!dtypep) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepDType;
        return;
    }

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user2p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user2p(), nodep, "Child 2 missing Dfg vertex");

    DfgLteS* const vtxp = makeVertex<DfgLteS>(nodep, m_dfg, *dtypep);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepNode;
        return;
    }
    m_logicp->synth().emplace_back(vtxp);

    vtxp->inputp(0, nodep->op1p()->user2u().to<DfgVertex*>());
    vtxp->inputp(1, nodep->op2p()->user2u().to<DfgVertex*>());

    nodep->user2p(vtxp);
}
void visit(AstModDiv* nodep) override {
    UASSERT_OBJ(m_converting, nodep, "AstToDfg visit called without m_converting");
    UASSERT_OBJ(!nodep->user2p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    const DfgDataType* const dtypep = DfgDataType::fromAst(nodep->dtypep());
    if (!dtypep) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepDType;
        return;
    }

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user2p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user2p(), nodep, "Child 2 missing Dfg vertex");

    DfgModDiv* const vtxp = makeVertex<DfgModDiv>(nodep, m_dfg, *dtypep);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepNode;
        return;
    }
    m_logicp->synth().emplace_back(vtxp);

    vtxp->inputp(0, nodep->op1p()->user2u().to<DfgVertex*>());
    vtxp->inputp(1, nodep->op2p()->user2u().to<DfgVertex*>());

    nodep->user2p(vtxp);
}
void visit(AstModDivS* nodep) override {
    UASSERT_OBJ(m_converting, nodep, "AstToDfg visit called without m_converting");
    UASSERT_OBJ(!nodep->user2p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    const DfgDataType* const dtypep = DfgDataType::fromAst(nodep->dtypep());
    if (!dtypep) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepDType;
        return;
    }

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user2p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user2p(), nodep, "Child 2 missing Dfg vertex");

    DfgModDivS* const vtxp = makeVertex<DfgModDivS>(nodep, m_dfg, *dtypep);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepNode;
        return;
    }
    m_logicp->synth().emplace_back(vtxp);

    vtxp->inputp(0, nodep->op1p()->user2u().to<DfgVertex*>());
    vtxp->inputp(1, nodep->op2p()->user2u().to<DfgVertex*>());

    nodep->user2p(vtxp);
}
void visit(AstMul* nodep) override {
    UASSERT_OBJ(m_converting, nodep, "AstToDfg visit called without m_converting");
    UASSERT_OBJ(!nodep->user2p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    const DfgDataType* const dtypep = DfgDataType::fromAst(nodep->dtypep());
    if (!dtypep) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepDType;
        return;
    }

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user2p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user2p(), nodep, "Child 2 missing Dfg vertex");

    DfgMul* const vtxp = makeVertex<DfgMul>(nodep, m_dfg, *dtypep);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepNode;
        return;
    }
    m_logicp->synth().emplace_back(vtxp);

    vtxp->inputp(0, nodep->op1p()->user2u().to<DfgVertex*>());
    vtxp->inputp(1, nodep->op2p()->user2u().to<DfgVertex*>());

    nodep->user2p(vtxp);
}
void visit(AstMulS* nodep) override {
    UASSERT_OBJ(m_converting, nodep, "AstToDfg visit called without m_converting");
    UASSERT_OBJ(!nodep->user2p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    const DfgDataType* const dtypep = DfgDataType::fromAst(nodep->dtypep());
    if (!dtypep) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepDType;
        return;
    }

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user2p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user2p(), nodep, "Child 2 missing Dfg vertex");

    DfgMulS* const vtxp = makeVertex<DfgMulS>(nodep, m_dfg, *dtypep);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepNode;
        return;
    }
    m_logicp->synth().emplace_back(vtxp);

    vtxp->inputp(0, nodep->op1p()->user2u().to<DfgVertex*>());
    vtxp->inputp(1, nodep->op2p()->user2u().to<DfgVertex*>());

    nodep->user2p(vtxp);
}
void visit(AstNegate* nodep) override {
    UASSERT_OBJ(m_converting, nodep, "AstToDfg visit called without m_converting");
    UASSERT_OBJ(!nodep->user2p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    const DfgDataType* const dtypep = DfgDataType::fromAst(nodep->dtypep());
    if (!dtypep) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepDType;
        return;
    }

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user2p(), nodep, "Child 1 missing Dfg vertex");

    DfgNegate* const vtxp = makeVertex<DfgNegate>(nodep, m_dfg, *dtypep);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepNode;
        return;
    }
    m_logicp->synth().emplace_back(vtxp);

    vtxp->inputp(0, nodep->op1p()->user2u().to<DfgVertex*>());

    nodep->user2p(vtxp);
}
void visit(AstNeq* nodep) override {
    UASSERT_OBJ(m_converting, nodep, "AstToDfg visit called without m_converting");
    UASSERT_OBJ(!nodep->user2p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    const DfgDataType* const dtypep = DfgDataType::fromAst(nodep->dtypep());
    if (!dtypep) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepDType;
        return;
    }

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user2p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user2p(), nodep, "Child 2 missing Dfg vertex");

    DfgNeq* const vtxp = makeVertex<DfgNeq>(nodep, m_dfg, *dtypep);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepNode;
        return;
    }
    m_logicp->synth().emplace_back(vtxp);

    vtxp->inputp(0, nodep->op1p()->user2u().to<DfgVertex*>());
    vtxp->inputp(1, nodep->op2p()->user2u().to<DfgVertex*>());

    nodep->user2p(vtxp);
}
void visit(AstNeqCase* nodep) override {
    UASSERT_OBJ(m_converting, nodep, "AstToDfg visit called without m_converting");
    UASSERT_OBJ(!nodep->user2p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    const DfgDataType* const dtypep = DfgDataType::fromAst(nodep->dtypep());
    if (!dtypep) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepDType;
        return;
    }

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user2p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user2p(), nodep, "Child 2 missing Dfg vertex");

    DfgNeqCase* const vtxp = makeVertex<DfgNeqCase>(nodep, m_dfg, *dtypep);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepNode;
        return;
    }
    m_logicp->synth().emplace_back(vtxp);

    vtxp->inputp(0, nodep->op1p()->user2u().to<DfgVertex*>());
    vtxp->inputp(1, nodep->op2p()->user2u().to<DfgVertex*>());

    nodep->user2p(vtxp);
}
void visit(AstNeqWild* nodep) override {
    UASSERT_OBJ(m_converting, nodep, "AstToDfg visit called without m_converting");
    UASSERT_OBJ(!nodep->user2p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    const DfgDataType* const dtypep = DfgDataType::fromAst(nodep->dtypep());
    if (!dtypep) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepDType;
        return;
    }

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user2p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user2p(), nodep, "Child 2 missing Dfg vertex");

    DfgNeqWild* const vtxp = makeVertex<DfgNeqWild>(nodep, m_dfg, *dtypep);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepNode;
        return;
    }
    m_logicp->synth().emplace_back(vtxp);

    vtxp->inputp(0, nodep->op1p()->user2u().to<DfgVertex*>());
    vtxp->inputp(1, nodep->op2p()->user2u().to<DfgVertex*>());

    nodep->user2p(vtxp);
}
void visit(AstNot* nodep) override {
    UASSERT_OBJ(m_converting, nodep, "AstToDfg visit called without m_converting");
    UASSERT_OBJ(!nodep->user2p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    const DfgDataType* const dtypep = DfgDataType::fromAst(nodep->dtypep());
    if (!dtypep) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepDType;
        return;
    }

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user2p(), nodep, "Child 1 missing Dfg vertex");

    DfgNot* const vtxp = makeVertex<DfgNot>(nodep, m_dfg, *dtypep);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepNode;
        return;
    }
    m_logicp->synth().emplace_back(vtxp);

    vtxp->inputp(0, nodep->op1p()->user2u().to<DfgVertex*>());

    nodep->user2p(vtxp);
}
void visit(AstOr* nodep) override {
    UASSERT_OBJ(m_converting, nodep, "AstToDfg visit called without m_converting");
    UASSERT_OBJ(!nodep->user2p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    const DfgDataType* const dtypep = DfgDataType::fromAst(nodep->dtypep());
    if (!dtypep) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepDType;
        return;
    }

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user2p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user2p(), nodep, "Child 2 missing Dfg vertex");

    DfgOr* const vtxp = makeVertex<DfgOr>(nodep, m_dfg, *dtypep);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepNode;
        return;
    }
    m_logicp->synth().emplace_back(vtxp);

    vtxp->inputp(0, nodep->op1p()->user2u().to<DfgVertex*>());
    vtxp->inputp(1, nodep->op2p()->user2u().to<DfgVertex*>());

    nodep->user2p(vtxp);
}
void visit(AstPow* nodep) override {
    UASSERT_OBJ(m_converting, nodep, "AstToDfg visit called without m_converting");
    UASSERT_OBJ(!nodep->user2p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    const DfgDataType* const dtypep = DfgDataType::fromAst(nodep->dtypep());
    if (!dtypep) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepDType;
        return;
    }

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user2p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user2p(), nodep, "Child 2 missing Dfg vertex");

    DfgPow* const vtxp = makeVertex<DfgPow>(nodep, m_dfg, *dtypep);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepNode;
        return;
    }
    m_logicp->synth().emplace_back(vtxp);

    vtxp->inputp(0, nodep->op1p()->user2u().to<DfgVertex*>());
    vtxp->inputp(1, nodep->op2p()->user2u().to<DfgVertex*>());

    nodep->user2p(vtxp);
}
void visit(AstPowSS* nodep) override {
    UASSERT_OBJ(m_converting, nodep, "AstToDfg visit called without m_converting");
    UASSERT_OBJ(!nodep->user2p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    const DfgDataType* const dtypep = DfgDataType::fromAst(nodep->dtypep());
    if (!dtypep) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepDType;
        return;
    }

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user2p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user2p(), nodep, "Child 2 missing Dfg vertex");

    DfgPowSS* const vtxp = makeVertex<DfgPowSS>(nodep, m_dfg, *dtypep);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepNode;
        return;
    }
    m_logicp->synth().emplace_back(vtxp);

    vtxp->inputp(0, nodep->op1p()->user2u().to<DfgVertex*>());
    vtxp->inputp(1, nodep->op2p()->user2u().to<DfgVertex*>());

    nodep->user2p(vtxp);
}
void visit(AstPowSU* nodep) override {
    UASSERT_OBJ(m_converting, nodep, "AstToDfg visit called without m_converting");
    UASSERT_OBJ(!nodep->user2p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    const DfgDataType* const dtypep = DfgDataType::fromAst(nodep->dtypep());
    if (!dtypep) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepDType;
        return;
    }

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user2p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user2p(), nodep, "Child 2 missing Dfg vertex");

    DfgPowSU* const vtxp = makeVertex<DfgPowSU>(nodep, m_dfg, *dtypep);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepNode;
        return;
    }
    m_logicp->synth().emplace_back(vtxp);

    vtxp->inputp(0, nodep->op1p()->user2u().to<DfgVertex*>());
    vtxp->inputp(1, nodep->op2p()->user2u().to<DfgVertex*>());

    nodep->user2p(vtxp);
}
void visit(AstPowUS* nodep) override {
    UASSERT_OBJ(m_converting, nodep, "AstToDfg visit called without m_converting");
    UASSERT_OBJ(!nodep->user2p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    const DfgDataType* const dtypep = DfgDataType::fromAst(nodep->dtypep());
    if (!dtypep) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepDType;
        return;
    }

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user2p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user2p(), nodep, "Child 2 missing Dfg vertex");

    DfgPowUS* const vtxp = makeVertex<DfgPowUS>(nodep, m_dfg, *dtypep);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepNode;
        return;
    }
    m_logicp->synth().emplace_back(vtxp);

    vtxp->inputp(0, nodep->op1p()->user2u().to<DfgVertex*>());
    vtxp->inputp(1, nodep->op2p()->user2u().to<DfgVertex*>());

    nodep->user2p(vtxp);
}
void visit(AstRedAnd* nodep) override {
    UASSERT_OBJ(m_converting, nodep, "AstToDfg visit called without m_converting");
    UASSERT_OBJ(!nodep->user2p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    const DfgDataType* const dtypep = DfgDataType::fromAst(nodep->dtypep());
    if (!dtypep) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepDType;
        return;
    }

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user2p(), nodep, "Child 1 missing Dfg vertex");

    DfgRedAnd* const vtxp = makeVertex<DfgRedAnd>(nodep, m_dfg, *dtypep);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepNode;
        return;
    }
    m_logicp->synth().emplace_back(vtxp);

    vtxp->inputp(0, nodep->op1p()->user2u().to<DfgVertex*>());

    nodep->user2p(vtxp);
}
void visit(AstRedOr* nodep) override {
    UASSERT_OBJ(m_converting, nodep, "AstToDfg visit called without m_converting");
    UASSERT_OBJ(!nodep->user2p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    const DfgDataType* const dtypep = DfgDataType::fromAst(nodep->dtypep());
    if (!dtypep) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepDType;
        return;
    }

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user2p(), nodep, "Child 1 missing Dfg vertex");

    DfgRedOr* const vtxp = makeVertex<DfgRedOr>(nodep, m_dfg, *dtypep);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepNode;
        return;
    }
    m_logicp->synth().emplace_back(vtxp);

    vtxp->inputp(0, nodep->op1p()->user2u().to<DfgVertex*>());

    nodep->user2p(vtxp);
}
void visit(AstRedXor* nodep) override {
    UASSERT_OBJ(m_converting, nodep, "AstToDfg visit called without m_converting");
    UASSERT_OBJ(!nodep->user2p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    const DfgDataType* const dtypep = DfgDataType::fromAst(nodep->dtypep());
    if (!dtypep) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepDType;
        return;
    }

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user2p(), nodep, "Child 1 missing Dfg vertex");

    DfgRedXor* const vtxp = makeVertex<DfgRedXor>(nodep, m_dfg, *dtypep);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepNode;
        return;
    }
    m_logicp->synth().emplace_back(vtxp);

    vtxp->inputp(0, nodep->op1p()->user2u().to<DfgVertex*>());

    nodep->user2p(vtxp);
}
void visit(AstReplicate* nodep) override {
    UASSERT_OBJ(m_converting, nodep, "AstToDfg visit called without m_converting");
    UASSERT_OBJ(!nodep->user2p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    const DfgDataType* const dtypep = DfgDataType::fromAst(nodep->dtypep());
    if (!dtypep) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepDType;
        return;
    }

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user2p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user2p(), nodep, "Child 2 missing Dfg vertex");

    DfgReplicate* const vtxp = makeVertex<DfgReplicate>(nodep, m_dfg, *dtypep);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepNode;
        return;
    }
    m_logicp->synth().emplace_back(vtxp);

    vtxp->inputp(0, nodep->op1p()->user2u().to<DfgVertex*>());
    vtxp->inputp(1, nodep->op2p()->user2u().to<DfgVertex*>());

    nodep->user2p(vtxp);
}
void visit(AstShiftL* nodep) override {
    UASSERT_OBJ(m_converting, nodep, "AstToDfg visit called without m_converting");
    UASSERT_OBJ(!nodep->user2p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    const DfgDataType* const dtypep = DfgDataType::fromAst(nodep->dtypep());
    if (!dtypep) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepDType;
        return;
    }

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user2p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user2p(), nodep, "Child 2 missing Dfg vertex");

    DfgShiftL* const vtxp = makeVertex<DfgShiftL>(nodep, m_dfg, *dtypep);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepNode;
        return;
    }
    m_logicp->synth().emplace_back(vtxp);

    vtxp->inputp(0, nodep->op1p()->user2u().to<DfgVertex*>());
    vtxp->inputp(1, nodep->op2p()->user2u().to<DfgVertex*>());

    nodep->user2p(vtxp);
}
void visit(AstShiftR* nodep) override {
    UASSERT_OBJ(m_converting, nodep, "AstToDfg visit called without m_converting");
    UASSERT_OBJ(!nodep->user2p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    const DfgDataType* const dtypep = DfgDataType::fromAst(nodep->dtypep());
    if (!dtypep) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepDType;
        return;
    }

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user2p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user2p(), nodep, "Child 2 missing Dfg vertex");

    DfgShiftR* const vtxp = makeVertex<DfgShiftR>(nodep, m_dfg, *dtypep);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepNode;
        return;
    }
    m_logicp->synth().emplace_back(vtxp);

    vtxp->inputp(0, nodep->op1p()->user2u().to<DfgVertex*>());
    vtxp->inputp(1, nodep->op2p()->user2u().to<DfgVertex*>());

    nodep->user2p(vtxp);
}
void visit(AstShiftRS* nodep) override {
    UASSERT_OBJ(m_converting, nodep, "AstToDfg visit called without m_converting");
    UASSERT_OBJ(!nodep->user2p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    const DfgDataType* const dtypep = DfgDataType::fromAst(nodep->dtypep());
    if (!dtypep) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepDType;
        return;
    }

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user2p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user2p(), nodep, "Child 2 missing Dfg vertex");

    DfgShiftRS* const vtxp = makeVertex<DfgShiftRS>(nodep, m_dfg, *dtypep);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepNode;
        return;
    }
    m_logicp->synth().emplace_back(vtxp);

    vtxp->inputp(0, nodep->op1p()->user2u().to<DfgVertex*>());
    vtxp->inputp(1, nodep->op2p()->user2u().to<DfgVertex*>());

    nodep->user2p(vtxp);
}
void visit(AstStreamL* nodep) override {
    UASSERT_OBJ(m_converting, nodep, "AstToDfg visit called without m_converting");
    UASSERT_OBJ(!nodep->user2p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    const DfgDataType* const dtypep = DfgDataType::fromAst(nodep->dtypep());
    if (!dtypep) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepDType;
        return;
    }

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user2p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user2p(), nodep, "Child 2 missing Dfg vertex");

    DfgStreamL* const vtxp = makeVertex<DfgStreamL>(nodep, m_dfg, *dtypep);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepNode;
        return;
    }
    m_logicp->synth().emplace_back(vtxp);

    vtxp->inputp(0, nodep->op1p()->user2u().to<DfgVertex*>());
    vtxp->inputp(1, nodep->op2p()->user2u().to<DfgVertex*>());

    nodep->user2p(vtxp);
}
void visit(AstStreamR* nodep) override {
    UASSERT_OBJ(m_converting, nodep, "AstToDfg visit called without m_converting");
    UASSERT_OBJ(!nodep->user2p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    const DfgDataType* const dtypep = DfgDataType::fromAst(nodep->dtypep());
    if (!dtypep) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepDType;
        return;
    }

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user2p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user2p(), nodep, "Child 2 missing Dfg vertex");

    DfgStreamR* const vtxp = makeVertex<DfgStreamR>(nodep, m_dfg, *dtypep);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepNode;
        return;
    }
    m_logicp->synth().emplace_back(vtxp);

    vtxp->inputp(0, nodep->op1p()->user2u().to<DfgVertex*>());
    vtxp->inputp(1, nodep->op2p()->user2u().to<DfgVertex*>());

    nodep->user2p(vtxp);
}
void visit(AstSub* nodep) override {
    UASSERT_OBJ(m_converting, nodep, "AstToDfg visit called without m_converting");
    UASSERT_OBJ(!nodep->user2p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    const DfgDataType* const dtypep = DfgDataType::fromAst(nodep->dtypep());
    if (!dtypep) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepDType;
        return;
    }

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user2p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user2p(), nodep, "Child 2 missing Dfg vertex");

    DfgSub* const vtxp = makeVertex<DfgSub>(nodep, m_dfg, *dtypep);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepNode;
        return;
    }
    m_logicp->synth().emplace_back(vtxp);

    vtxp->inputp(0, nodep->op1p()->user2u().to<DfgVertex*>());
    vtxp->inputp(1, nodep->op2p()->user2u().to<DfgVertex*>());

    nodep->user2p(vtxp);
}
void visit(AstXor* nodep) override {
    UASSERT_OBJ(m_converting, nodep, "AstToDfg visit called without m_converting");
    UASSERT_OBJ(!nodep->user2p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    const DfgDataType* const dtypep = DfgDataType::fromAst(nodep->dtypep());
    if (!dtypep) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepDType;
        return;
    }

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user2p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user2p(), nodep, "Child 2 missing Dfg vertex");

    DfgXor* const vtxp = makeVertex<DfgXor>(nodep, m_dfg, *dtypep);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_conv.nonRepNode;
        return;
    }
    m_logicp->synth().emplace_back(vtxp);

    vtxp->inputp(0, nodep->op1p()->user2u().to<DfgVertex*>());
    vtxp->inputp(1, nodep->op2p()->user2u().to<DfgVertex*>());

    nodep->user2p(vtxp);
}
